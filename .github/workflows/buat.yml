name: Build selected Tachiyomi extension

on:
  workflow_dispatch:
    inputs:
      module:
        description: 'Module name to build. Use "all" to build everything (default). Examples: extension-xyz or :extension-xyz'
        required: true
        default: 'all'
      buildType:
        description: 'Build variant'
        required: true
        default: 'Release'
        type: choice
        options:
          - Release
          - Debug

env:
  ANDROID_COMPILE_SDK: "28"
  BUILD_TOOLS_VERSION: "28.0.3"
  GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx1536m"

jobs:
  build:
    name: Build chosen module
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '1.8'
          cache: 'gradle'

      - name: Set ANDROID env vars
        run: |
          echo "ANDROID_HOME=/usr/local/android-sdk" >> $GITHUB_ENV
          echo "ANDROID_SDK_ROOT=/usr/local/android-sdk" >> $GITHUB_ENV
          mkdir -p /usr/local/android-sdk

      - name: Setup Android SDK (platform & build-tools)
        uses: r0adkll/setup-android@v2
        with:
          api-levels: ${{ env.ANDROID_COMPILE_SDK }}
          build-tools: ${{ env.BUILD_TOOLS_VERSION }}

      - name: Make gradlew executable
        run: chmod +x ./gradlew || true

      - name: Show Gradle & Java versions
        run: |
          java -version || true
          ./gradlew --version || true

      - name: List modules from settings.gradle / settings.gradle.kts
        id: list-modules
        run: |
          echo "Looking for settings.gradle / settings.gradle.kts..."
          modules=()
          for f in settings.gradle settings.gradle.kts; do
            if [ -f "$f" ]; then
              echo "-> parsing $f"
              # ambil baris yang mengandung include lalu pisah bagian after include
              grep -n "include" "$f" | while IFS= read -r line; do
                # ambil setelah kata include, hapus kurung dan quotes, split by comma
                after=$(echo "$line" | sed -E "s/.*include[[:space:]]*\\(?//; s/\\)?$//")
                # split by comma
                IFS=',' read -ra parts <<< "$after"
                for p in "${parts[@]}"; do
                  # bersihkan quotes, spaces
                  clean=$(echo "$p" | sed -E "s/[\"'[:space:]]//g")
                  if [ -n "$clean" ]; then
                    modules+=("$clean")
                  fi
                done
              done
            fi
          done
          # unique & print
          if [ ${#modules[@]} -eq 0 ]; then
            echo "No includes found in settings.gradle files. If you use unconventional structure, the module list may be empty."
          else
            # remove duplicates
            uniq_modules=$(printf "%s\n" "${modules[@]}" | awk '!x[$0]++')
            echo "Found modules (as in settings.gradle):"
            echo "$uniq_modules"
          fi
          # export as output for later step
          printf "%s\n" "${modules[@]}" > modules.txt
          echo "::set-output name=modules_file::modules.txt"

      - name: Build selected module
        env:
          SELECTED_MODULE: ${{ inputs.module }}
          BUILD_TYPE: ${{ inputs.buildType }}
        run: |
          set -e
          echo "Requested module: '$SELECTED_MODULE'  Build type: $BUILD_TYPE"
          # read modules file if present
          modules=()
          if [ -f modules.txt ]; then
            while IFS= read -r l; do
              [ -n "$l" ] && modules+=("$l")
            done < modules.txt
          fi

          # Normalize target function
          assembleTask() {
            local target="$1"
            # ensure target starts with colon
            if [[ "$target" != :* ]]; then
              target=":${target}"
            fi
            echo "Running: ./gradlew ${target}:assemble${BUILD_TYPE} -x lint --no-daemon --stacktrace"
            ./gradlew "${target}:assemble${BUILD_TYPE}" -x lint --no-daemon --stacktrace
          }

          if [ "$SELECTED_MODULE" = "all" ] || [ -z "$SELECTED_MODULE" ]; then
            echo "Building all modules (root assemble${BUILD_TYPE})"
            ./gradlew assemble${BUILD_TYPE} -x lint --no-daemon --stacktrace
          else
            # try to match selected module to listed modules (allow both with and without leading colon)
            found=false
            for m in "${modules[@]}"; do
              # compare normalized names
              nm="$m"
              nm_no_col=${nm#:}
              if [ "$nm" = "$SELECTED_MODULE" ] || [ "$nm_no_col" = "$SELECTED_MODULE" ] || [ "$nm" = ":$SELECTED_MODULE" ] ; then
                target="$nm"
                # ensure target has leading colon for assembleTask
                if [[ "$target" != :* ]]; then target=":$target"; fi
                found=true
                break
              fi
            done

            if [ "$found" = true ]; then
              echo "Found module $target in settings.gradle. Building..."
              assembleTask "$target"
            else
              # fallback: try to build using input as module name (with/without colon)
              echo "Module '$SELECTED_MODULE' not found in parsed settings.gradle. Attempting to build using input as-is..."
              # try with leading colon
              assembleTask "$SELECTED_MODULE" || assembleTask ":$SELECTED_MODULE" || {
                echo "Failed to build module using guessed names. Available modules (parsed):"
                printf "%s\n" "${modules[@]}"
                exit 1
              }
            fi
          fi

      - name: Collect build outputs (debug list)
        run: |
          echo "Artifacts produced:"
          find . -type f -name "*.apk" -o -name "*.aar" -o -name "*.jar" || true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: extension-build
          path: |
            **/build/outputs/**/*.apk
            **/build/outputs/**/*.aar
            **/build/libs/*.jar
